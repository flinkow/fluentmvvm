<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<# Type[] types = { typeof(object), typeof(bool), typeof(byte), typeof(sbyte), typeof(char), typeof(decimal), typeof(double), typeof(float), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(DateTime), typeof(string) }; #>
// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Windows.Input;
using System.Diagnostics.CodeAnalysis;
using FluentMvvm.Internals;

namespace FluentMvvm
{
    /// <summary>
    ///     A base class for view models implementing <see cref="INotifyPropertyChanged" /> and providing a fluent API for
    ///     property setters.
    /// </summary>
    /// <seealso cref="System.ComponentModel.INotifyPropertyChanged" />
    public abstract class FluentViewModelBase : IPropertyGetExpression, IPropertySetExpression, IConditionalExpression, IDependencyExpression, INotifyPropertyChanged
    {
        private readonly bool createBackingFields;

#if TEST
        internal virtual IBackingFields BackingFields { get; }
#else
        private IBackingFields BackingFields;
#endif

        /// <summary>
        /// Initializes a new instance of the <see cref="FluentViewModelBase"/> class.
        /// </summary>
        /// <param name="createBackingFields">Must be set to <c>true</c> in order to use the <c>Get</c> and <c>Set</c> methods.</param>
        protected FluentViewModelBase(bool createBackingFields = true)
        {
            this.createBackingFields = createBackingFields;

            if (!this.createBackingFields)
            {
                this.BackingFields = new BackingFieldsCreationDisabled(this.GetType());
                return;
            }

#if TEST
            this.BackingFields = new BackingFields();
#else
            this.BackingFields = new BackingFields(this.GetType(), this.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public));
#endif
        }

<# foreach (Type type in types) { #>
        /// <summary>
        ///     Gets the value of the specified property.
        /// </summary>
        /// <param name="propertyName">
        ///     The name of the property. Filled in by the compiler automatically, do not specify explicitly.
        /// </param>
        /// <returns>
        ///     The value of the property.
        /// </returns>
        /// <exception cref="ArgumentException">
        ///     no public writable instance property named <paramref name="propertyName" /> could be found -or- <paramref name="propertyName" /> is empty or consists only of white-space characters.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        ///     there are no backing fields of type <#= type == typeof(object) ? "<typeparamref name=\"T\" />" : "<see cref=\"" + type + "\" />" #>.
        /// </exception>
        public <#= type == typeof(object) ? "T" : type.Name #> Get<#= type == typeof(object) ? "<T>" : type.Name #>([CallerMemberName] string propertyName = "")
        {
            return this.BackingFields.Get<#= type == typeof(object) ? "<T>" : type.Name #>(propertyName);
        }

<# } #>
<# foreach (Type type in types) { #>
        /// <summary>
        ///     Sets the value of the specified property to <paramref name="value" /> and raises a
        ///     <see cref="INotifyPropertyChanged.PropertyChanged" /> event if the new value was different from the old value.
        /// </summary>
        /// <param name="value">The value to set the property to.</param>
        /// <param name="propertyName">
        ///     The name of the property. Filled in by the compiler automatically, do not specify explicitly.
        /// </param>
        /// <returns></returns>
        /// <exception cref="ArgumentException">
        ///     no public writable instance property named <paramref name="propertyName" /> could be found -or- <paramref name="propertyName" /> is empty or consists only of white-space characters.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        ///     there are no backing fields of type <#= type == typeof(object) ? "<typeparamref name=\"T\" />" : "<see cref=\"" + type + "\" />" #>.
        /// </exception>
        public IDependencyExpression Set<#= type == typeof(object) ? "<T>" : String.Empty #>(<#= type == typeof(object) ? "[AllowNull] T" : type.Name #> value, [CallerMemberName] string propertyName = "")
        {
            if (this.BackingFields.Set(value, propertyName))
            {
                Debug.Assert(!String.IsNullOrWhiteSpace(propertyName));

                this.RaisePropertyChanged(propertyName);
                return this;
            }

            return EmptyFluentAction.Default;
        }

<# } #>
        /// <summary>
        ///     Sets the value of the specified property to <paramref name="value" /> and raises a
        ///     <see cref="INotifyPropertyChanged.PropertyChanged" /> event if the new value was different from the old value.
        /// </summary>
        /// <param name="value">The value to set the property to.</param>
        /// <param name="oldValue">A reference to the old value of the property. This can be a field.</param>
        /// <param name="propertyName">
        ///     The name of the property. Filled in by the compiler automatically, do not specify explicitly.
        /// </param>
        /// <returns></returns>
        /// <exception cref="ArgumentException">
        ///     no public writable instance property named <paramref name="propertyName" /> could be found -or- <paramref name="propertyName" /> is empty or consists only of white-space characters.
        /// </exception>
        public IDependencyExpression Set<T>(T value, ref T oldValue, [CallerMemberName] string propertyName = "")
        {
            if (EqualityComparer<T>.Default.Equals(value, oldValue))
            {
                return EmptyFluentAction.Default;
            }

            oldValue = value;
            this.RaisePropertyChanged(propertyName);

            return this;
        }

        /// <summary>
        ///     If <paramref name="condition" /> is <c>false</c>, no following
        ///     <c>Set</c>, <see cref="IDependencyExpression.Affects(string)" /> or
        ///     <see cref="IDependencyExpression.Affects(System.Windows.Input.ICommand)" /> will be executed.
        /// </summary>
        /// <param name="condition">only if set to <c>true</c> will the following fluent calls be executed.</param>
        public IPropertySetExpression When(bool condition)
        {
            return condition ? (IPropertySetExpression) this : EmptyFluentAction.Default;
        }

        /// <summary>
        ///     If <paramref name="condition" /> evaluates to <c>false</c>, no following
        ///     <c>Set</c>, <see cref="IDependencyExpression.Affects(string)" /> or
        ///     <see cref="IDependencyExpression.Affects(System.Windows.Input.ICommand)" /> will be executed.
        /// </summary>
        /// <param name="condition">only if evaluates to <c>true</c> will the following fluent calls be executed.</param>
        /// <exception cref="ArgumentNullException"><paramref name="condition" /> is <c>null</c>.</exception>
        public IPropertySetExpression When(Func<bool> condition)
        {
            condition.NotNull(nameof(condition));

            return this.When(condition());
        }

        /// <summary>
        ///     Raises a <see cref="INotifyPropertyChanged.PropertyChanged" /> event for the property
        ///     <paramref name="propertyName" /> if the new property value was different from the old value.
        /// </summary>
        /// <param name="propertyName">The name of the property that changes when this property changes.</param>
        /// <returns></returns>
        /// <exception cref="ArgumentException">
        ///     <paramref name="propertyName" /> is null, empty or consists only of white-space
        ///     characters.
        /// </exception>
        IDependencyExpression IDependencyExpression.Affects(string propertyName)
        {
            propertyName.NotNullOrEmptyOrWhiteSpace(nameof(propertyName));

            this.RaisePropertyChanged(propertyName);

            return this;
        }

        /// <summary>
        ///     Raises a <see cref="ICommand.CanExecuteChanged" /> event for the <see cref="ICommand" /> if the new property
        ///     value was different from the old value.
        /// </summary>
        /// <param name="command">The command.</param>
        /// <returns></returns>
        /// <exception cref="Microsoft.CSharp.RuntimeBinder.RuntimeBinderException">
        ///     <paramref name="command" /> does not provide a public, parameter-less
        ///     <c>RaiseCanExecuteChanged</c> method.
        /// </exception>
        /// <exception cref="ArgumentNullException"><paramref name="command" /> is <c>null</c>.</exception>
        /// <remarks>
        ///     For this method to work correctly, <paramref name="command" /> must provide a
        ///     <c>public void RaiseCanExecuteChanged()</c> method.
        /// </remarks>
        IDependencyExpression IDependencyExpression.Affects(ICommand command)
        {
            command.NotNull(nameof(command));

            ((dynamic) command).RaiseCanExecuteChanged();

            return this;
        }

        /// <summary>
        ///     Raises a <see cref="ICommand.CanExecuteChanged" /> event for the <see cref="IWpfCommand" /> if the new property
        ///     value was different from the old value.
        /// </summary>
        /// <param name="command">The command.</param>
        /// <returns></returns>
        /// <exception cref="ArgumentNullException"><paramref name="command" /> is <c>null</c>.</exception>
        IDependencyExpression IDependencyExpression.Affects(IWpfCommand command)
        {            
            command.NotNull(nameof(command));

            command.RaiseCanExecuteChanged();

            return this;
        }

        /// <summary>
        ///     Returns a value indicating whether the new property value was different from the old value.
        /// </summary>
        /// <returns>
        ///     <c>true</c> if the new property value was different from the old value; otherwise, <c>false</c>.
        /// </returns>
        bool IDependencyExpression.WasUpdated()
        {
            return true;
        }

        /// <inheritdoc />
        public event PropertyChangedEventHandler? PropertyChanged;

        /// <summary>
        ///     Notifies listeners that the property <paramref name="propertyName" /> has changed.
        /// </summary>
        /// <param name="propertyName">
        ///     The name of the property that has changed. You should not provide the name yourself and rely
        ///     on the compiler inserting the name automatically for you.
        /// </param>
        protected internal virtual void RaisePropertyChanged([CallerMemberName] [NotNull] string propertyName = "")
        {
            Debug.Assert(propertyName != null);
            this.PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
