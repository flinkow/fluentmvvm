<?xml version="1.0"?>
<doc>
    <assembly>
        <name>fluentmvvm</name>
    </assembly>
    <members>
        <member name="T:FluentMvvm.BackingFieldProvider">
            <summary>Builds a class containing the backing fields for a view model's public writable instance properties.</summary>
        </member>
        <member name="F:FluentMvvm.BackingFieldProvider.AssemblyName">
            <summary>The name of the generated assembly.</summary>
        </member>
        <member name="F:FluentMvvm.BackingFieldProvider.AssemblyNamespace">
            <summary>The namespace of the generated types.</summary>
        </member>
        <member name="F:FluentMvvm.BackingFieldProvider.GeneratedTypeAttributes">
            <summary>The <see cref="T:System.Reflection.TypeAttributes" /> if the generated types.</summary>
        </member>
        <member name="F:FluentMvvm.BackingFieldProvider.GeneratedMethodAttributes">
            <summary>
                The <see cref="T:System.Reflection.MethodAttributes" /> for the implementations of
                <see cref="M:FluentMvvm.IBackingFieldProvider.GetValueOf(System.String)" />,
                <see cref="M:FluentMvvm.IBackingFieldProvider.SetValueOf(System.String,System.Object)" /> methods.
            </summary>
        </member>
        <member name="F:FluentMvvm.BackingFieldProvider.assemblyBuilder">
            <summary>The dynamic assembly builder.</summary>
        </member>
        <member name="F:FluentMvvm.BackingFieldProvider.moduleBuilder">
            <summary>The module builder of the dynamic assembly.</summary>
        </member>
        <member name="F:FluentMvvm.BackingFieldProvider.GetValueOfMethodInfo">
            <summary>The <see cref="T:System.Reflection.MethodInfo" /> for the <see cref="M:FluentMvvm.IBackingFieldProvider.GetValueOf(System.String)" /> method.</summary>
        </member>
        <member name="F:FluentMvvm.BackingFieldProvider.SetValueOfMethodInfo">
            <summary>The <see cref="T:System.Reflection.MethodInfo" /> for the <see cref="M:FluentMvvm.IBackingFieldProvider.SetValueOf(System.String,System.Object)" /> method.</summary>
        </member>
        <member name="F:FluentMvvm.BackingFieldProvider.Cache">
            <summary>A cache for generated types to avoid defining new types for the same target type.</summary>
        </member>
        <member name="M:FluentMvvm.BackingFieldProvider.Get(System.Type)">
            <summary>
                Gets the class containing the backing fields of <paramref name="targetType" />'s public writable instance
                properties.
            </summary>
            <remarks>The backing fields are named exactly as their properties.</remarks>
            <param name="targetType">The type of the view model to generate the backing fields for.</param>
            <returns>
                A class containing backing fields for all public writable instance properties of
                <paramref name="targetType" />.
            </returns>
        </member>
        <member name="M:FluentMvvm.BackingFieldProvider.BuildForType(System.Type)">
            <summary>
                Builds the class containing the backing fields of <paramref name="targetType" />'s public writable instance
                properties.
            </summary>
            <param name="targetType">The type of the view model to generate the backing fields for.</param>
            <returns>The type of the class containing the backing fields</returns>
        </member>
        <member name="M:FluentMvvm.BackingFieldProvider.GetRelevantProperties(System.Type)">
            <summary>
                Gets the properties to build backing fields for. Only considers public writable instance properties that do
                not have a <see cref="T:FluentMvvm.SuppressFieldGenerationAttribute" /> applied to them.
            </summary>
            <param name="type">The type to build backing fields for.</param>
            <returns>A collection of all properties to build backing fields for.</returns>
        </member>
        <member name="M:FluentMvvm.BackingFieldProvider.BuildBackingFields(System.Collections.Generic.IReadOnlyList{System.Reflection.PropertyInfo},System.Reflection.Emit.TypeBuilder)">
            <summary>Builds the backing fields for the public writable instance properties <paramref name="properties" />.</summary>
            <param name="properties">The properties to build backing fields for.</param>
            <param name="typeBuilder">The type builder.</param>
            <returns>The generated backing fields.</returns>
        </member>
        <member name="M:FluentMvvm.BackingFieldProvider.BuildConstructor(System.Reflection.Emit.TypeBuilder,System.Collections.Generic.IReadOnlyList{System.Reflection.PropertyInfo},System.Collections.Generic.IReadOnlyList{System.Reflection.FieldInfo})">
            <summary>Builds the constructor of the class containing the backing fields.</summary>
            <param name="typeBuilder">The type builder.</param>
            <param name="properties">The public writable instance properties of the view model.</param>
            <param name="fields">The backing fields.</param>
        </member>
        <member name="M:FluentMvvm.BackingFieldProvider.BuildGetValueOf(System.Reflection.MemberInfo,System.Reflection.Emit.TypeBuilder,System.Collections.Generic.IReadOnlyList{System.Reflection.FieldInfo})">
            <summary>Builds the <see cref="M:FluentMvvm.IBackingFieldProvider.GetValueOf(System.String)" /> method.</summary>
            <param name="targetType">The type of the view model to generate the backing fields for.</param>
            <param name="typeBuilder">The type builder.</param>
            <param name="fields">The backing fields.</param>
        </member>
        <member name="M:FluentMvvm.BackingFieldProvider.BuildSetValueOf(System.Reflection.MemberInfo,System.Reflection.Emit.TypeBuilder,System.Collections.Generic.IReadOnlyList{System.Reflection.FieldInfo})">
            <summary>Builds the <see cref="M:FluentMvvm.IBackingFieldProvider.SetValueOf(System.String,System.Object)" /> method.</summary>
            <param name="targetType">The type of the view model to generate the backing fields for.</param>
            <param name="typeBuilder">The type builder.</param>
            <param name="fields">The backing fields.</param>
        </member>
        <member name="M:FluentMvvm.BackingFieldProvider.WriteMethodBody(System.Reflection.Emit.ILGenerator,System.Collections.Generic.IReadOnlyList{System.Reflection.FieldInfo},System.String,System.Boolean)">
            <summary>
                Writes the method bodies for the <see cref="M:FluentMvvm.IBackingFieldProvider.GetValueOf(System.String)" /> and
                <see cref="M:FluentMvvm.IBackingFieldProvider.SetValueOf(System.String,System.Object)" /> methods.
            </summary>
            <param name="ilGenerator">The <see cref="T:System.Reflection.Emit.ILGenerator" />.</param>
            <param name="fieldInfos">The backing fields.</param>
            <param name="targetTypeName">The name of the view model.</param>
            <param name="isGetValue">
                if set to <c>true</c>, code specific for <see cref="M:FluentMvvm.IBackingFieldProvider.GetValueOf(System.String)" /> is
                generated; otherwise, code specific for <see cref="M:FluentMvvm.IBackingFieldProvider.SetValueOf(System.String,System.Object)" /> is generated.
            </param>
        </member>
        <member name="T:FluentMvvm.FluentViewModelBase">
            <summary>
                A base class for ViewModels implementing <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> and providing a fluent API for
                property setters.
            </summary>
            <seealso cref="T:FluentMvvm.Fluent.IPropertySetExpression" />
            <seealso cref="T:FluentMvvm.Fluent.IConditionalExpression" />
            <seealso cref="T:FluentMvvm.Fluent.IDependencyExpression" />
            <seealso cref="T:System.ComponentModel.INotifyPropertyChanged" />
            <inheritdoc cref="T:FluentMvvm.Fluent.IPropertySetExpression" />
            <inheritdoc cref="T:FluentMvvm.Fluent.IConditionalExpression" />
        </member>
        <member name="F:FluentMvvm.FluentViewModelBase.backingFieldProvider">
            <summary>The dynamically generated type containing the backing fields for the concrete view model.</summary>
        </member>
        <member name="M:FluentMvvm.FluentViewModelBase.#ctor">
            <summary>Initializes a new instance of the <see cref="T:FluentMvvm.FluentViewModelBase" /> class.</summary>
        </member>
        <member name="M:FluentMvvm.FluentViewModelBase.When(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:FluentMvvm.FluentViewModelBase.When(System.Func{System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:FluentMvvm.FluentViewModelBase.Get``1(System.String)">
            <summary>Gets the value of the specified property.</summary>
            <typeparam name="T">The type of the property.</typeparam>
            <param name="propertyName">The name of the property.</param>
            <returns>The value of the property.</returns>
            <exception cref="T:System.ArgumentException">
                no public writable instance property named <paramref name="propertyName" /> could
                be found.
            </exception>
            <exception cref="T:System.NullReferenceException">
                the type has no public writable instance methods at all -or- the type is
                marked with <see cref="T:FluentMvvm.SuppressFieldGenerationAttribute" />.
            </exception>
        </member>
        <member name="M:FluentMvvm.FluentViewModelBase.Set(System.Object,System.String)">
            <inheritdoc />
        </member>
        <member name="M:FluentMvvm.FluentViewModelBase.FluentMvvm#Fluent#IDependencyExpression#Affects(System.String)">
            <inheritdoc />
        </member>
        <member name="M:FluentMvvm.FluentViewModelBase.FluentMvvm#Fluent#IDependencyExpression#Affects(System.Windows.Input.ICommand)">
            <inheritdoc />
        </member>
        <member name="M:FluentMvvm.FluentViewModelBase.FluentMvvm#Fluent#IDependencyExpression#WasUpdated">
            <inheritdoc />
        </member>
        <member name="E:FluentMvvm.FluentViewModelBase.PropertyChanged">
            <inheritdoc />
        </member>
        <member name="M:FluentMvvm.FluentViewModelBase.RaisePropertyChanged(System.String)">
            <summary>Notifies listeners that the property <paramref name="propertyName" /> has changed.</summary>
            <param name="propertyName">
                The name of the property that has changed. You should not provide the name yourself and rely
                on the compiler inserting the name automatically for you.
            </param>
        </member>
        <member name="T:FluentMvvm.Fluent.EmptyFluentAction">
            <summary>An object implementing all fluent methods as methods doing nothing.</summary>
            <seealso cref="T:FluentMvvm.Fluent.IPropertySetExpression" />
            <seealso cref="T:FluentMvvm.Fluent.IDependencyExpression" />
            <seealso cref="T:FluentMvvm.Fluent.IPropertySetExpression" />
            <seealso cref="T:FluentMvvm.Fluent.IDependencyExpression" />
        </member>
        <member name="P:FluentMvvm.Fluent.EmptyFluentAction.Default">
            <summary>Gets a singleton <see cref="T:FluentMvvm.Fluent.EmptyFluentAction" />.</summary>
            <value>A singleton instance of an <see cref="T:FluentMvvm.Fluent.EmptyFluentAction" />.</value>
        </member>
        <member name="M:FluentMvvm.Fluent.EmptyFluentAction.Affects(System.String)">
            <inheritdoc />
        </member>
        <member name="M:FluentMvvm.Fluent.EmptyFluentAction.Affects(System.Windows.Input.ICommand)">
            <inheritdoc />
        </member>
        <member name="M:FluentMvvm.Fluent.EmptyFluentAction.WasUpdated">
            <inheritdoc />
        </member>
        <member name="M:FluentMvvm.Fluent.EmptyFluentAction.Set(System.Object,System.String)">
            <inheritdoc />
        </member>
        <member name="T:FluentMvvm.Fluent.IConditionalExpression">
            <summary>Provides methods that determine whether or not the following fluent calls should execute.</summary>
        </member>
        <member name="M:FluentMvvm.Fluent.IConditionalExpression.When(System.Boolean)">
            <summary>
                If <paramref name="condition" /> is <c>false</c>, no following
                <see cref="M:FluentMvvm.Fluent.IPropertySetExpression.Set(System.Object,System.String)" />, <see cref="M:FluentMvvm.Fluent.IDependencyExpression.Affects(System.String)" /> or
                <see cref="M:FluentMvvm.Fluent.IDependencyExpression.Affects(System.Windows.Input.ICommand)" /> will be executed.
            </summary>
            <param name="condition">only if set to <c>true</c> will the following fluent calls be executed.</param>
        </member>
        <member name="M:FluentMvvm.Fluent.IConditionalExpression.When(System.Func{System.Boolean})">
            <summary>
                If <paramref name="condition" /> evaluates <c>false</c>, no following
                <see cref="M:FluentMvvm.Fluent.IPropertySetExpression.Set(System.Object,System.String)" />, <see cref="M:FluentMvvm.Fluent.IDependencyExpression.Affects(System.String)" /> or
                <see cref="M:FluentMvvm.Fluent.IDependencyExpression.Affects(System.Windows.Input.ICommand)" /> will be executed.
            </summary>
            <param name="condition">only if evaluates to <c>true</c> will the following fluent calls be executed.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition" /> is <c>null</c>.</exception>
        </member>
        <member name="T:FluentMvvm.Fluent.IDependencyExpression">
            <summary>Provides method to express dependencies between properties or between a property and a command.</summary>
        </member>
        <member name="M:FluentMvvm.Fluent.IDependencyExpression.Affects(System.String)">
            <summary>
                Raises a <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> event for the property
                <paramref name="propertyName" /> if the new property value was different from the old value.
            </summary>
            <param name="propertyName">The name of the property that changes when this property changes.</param>
        </member>
        <member name="M:FluentMvvm.Fluent.IDependencyExpression.Affects(System.Windows.Input.ICommand)">
            <summary>
                Raises a <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged" /> event for the <see cref="T:System.Windows.Input.ICommand" /> if the new property
                value was different from the old value.
            </summary>
            <remarks>
                For this method to work correctly, <paramref name="command" /> must provide a
                <c>public void RaiseCanExecuteChanged()</c> method.
            </remarks>
            <param name="command">The command.</param>
            <exception cref="T:Microsoft.CSharp.RuntimeBinder.RuntimeBinderException"><paramref name="command"/> does not provide a public, parameterless <c>RaiseCanExecuteChanged</c> method.</exception>
        </member>
        <member name="M:FluentMvvm.Fluent.IDependencyExpression.WasUpdated">
            <summary>Returns a value indicating whether the new property value was different from the old value.</summary>
            <returns><c>true</c> if the new property value was different from the old value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:FluentMvvm.Fluent.IPropertySetExpression">
            <summary>Provides methods that can be used to set a property value.</summary>
            <seealso cref="T:System.ComponentModel.INotifyPropertyChanged" />
        </member>
        <member name="M:FluentMvvm.Fluent.IPropertySetExpression.Set(System.Object,System.String)">
            <summary>
                Sets the value of this property to <paramref name="value" /> and raises a
                <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> event if the new value was different from the old value.
            </summary>
            <remarks>Intended to be used in property <c>set</c> accessors only.</remarks>
            <param name="value">The value to set the property to.</param>
            <param name="propertyName">The name of the property. Filled in by the compiler automatically.</param>
            <exception cref="T:System.ArgumentException">
                no public writable instance property named <paramref name="propertyName" /> could
                be found.
            </exception>
            <exception cref="T:System.NullReferenceException">
                the type has no public writable instance methods at all -or- the type is
                marked with <see cref="T:FluentMvvm.SuppressFieldGenerationAttribute" />.
            </exception>
        </member>
        <member name="T:FluentMvvm.IBackingFieldProvider">
            <summary>
                The base interface for dynamically generated types containing the backing fields of a view model's writable
                public instance properties.
            </summary>
        </member>
        <member name="M:FluentMvvm.IBackingFieldProvider.GetValueOf(System.String)">
            <summary>Gets the value of backing field of the property <paramref name="propertyName" />.</summary>
            <param name="propertyName">The name of the property.</param>
            <returns>The value of the backing field of <paramref name="propertyName" />.</returns>
            <exception cref="T:System.ArgumentException">
                no public, writable instance property with the specified property name could be
                found.
            </exception>
        </member>
        <member name="M:FluentMvvm.IBackingFieldProvider.SetValueOf(System.String,System.Object)">
            <summary>
                Sets the value of the backing field of the property <paramref name="propertyName" /> if it differs from the
                current property value.
            </summary>
            <param name="propertyName">The name of the property.</param>
            <param name="value">The value to set to the property.</param>
            <returns><c>true</c> if <paramref name="value" /> differed from the old value; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentException">
                no public, writable instance property with the specified property name could be
                found.
            </exception>
        </member>
        <member name="T:FluentMvvm.IWpfCommand">
            <inheritdoc />
            <summary>
                The base interface for WPF commands allowing consumers to raise the
                <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged" /> event.
            </summary>
            <seealso cref="T:System.Windows.Input.ICommand" />
        </member>
        <member name="M:FluentMvvm.IWpfCommand.RaiseCanExecuteChanged">
            <summary>Raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> event.</summary>
        </member>
        <member name="T:FluentMvvm.SuppressFieldGenerationAttribute">
            <inheritdoc />
            <summary>Indicates that no backing field shall be generated for the property or type the attribute is applied to.</summary>
            <remarks>If applied to a type, no backing field is generated for any property of that type.</remarks>
            <seealso cref="T:System.Attribute" />
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
                Indicates that the value of the marked element could be <c>null</c> sometimes, so checking for <c>null</c> is
                required before its usage.
            </summary>
            <example>
                <code>
            [CanBeNull] object Test() => null;
            
            void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>Indicates that the value of the marked element can never be <c>null</c>.</summary>
            <example>
                <code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.ItemNotNullAttribute">
            <summary>
                Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task and Lazy classes to
                indicate that the value of a collection item, of the Task.Result property or of the Lazy.Value property can never
                be null.
            </summary>
            <example>
                <code>
            public void Foo([ItemNotNull]List&lt;string&gt; books)
            {
              foreach (var book in books) {
                if (book != null) // Warning: Expression is always true
                 Console.WriteLine(book.ToUpper());
              }
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.ItemCanBeNullAttribute">
            <summary>
                Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task and Lazy classes to
                indicate that the value of a collection item, of the Task.Result property or of the Lazy.Value property can be
                null.
            </summary>
            <example>
                <code>
            public void Foo([ItemCanBeNull]List&lt;string&gt; books)
            {
              foreach (var book in books)
              {
                // Warning: Possible 'System.NullReferenceException'
                Console.WriteLine(book.ToUpper());
              }
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>Describes dependency between method input and output.</summary>
            <syntax>
                <p>Function Definition Table syntax:</p>
                <list>
                    <item>FDT      ::= FDTRow [;FDTRow]*</item> <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
                    <item>Input    ::= ParameterName: Value [, Input]*</item>
                    <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
                    <item>Value    ::= true | false | null | notnull | canbenull</item>
                </list>
                If the method has a single input parameter, its name could be omitted.<br /> Using <c>halt</c> (or <c>void</c>/
                <c>nothing</c>, which is the same) for the method output means that the method doesn't return normally (throws or
                terminates the process).<br /> Value <c>canbenull</c> is only applicable for output parameters.<br /> You can use
                multiple <c>[ContractAnnotation]</c> for each FDT row, or use single attribute with rows separated by semicolon.
                There is no notion of order rows, all rows are checked for applicability and applied per each program state tracked
                by the analysis engine.<br />
            </syntax>
            <examples>
                <list>
                    <item>
                        <code>
            [ContractAnnotation("=&gt; halt")]
            public void TerminationMethod()
            </code>
                    </item>
                    <item>
                        <code>
            [ContractAnnotation("null &lt;= param:null")] // reverse condition syntax
            public string GetName(string surname)
            </code>
                    </item>
                    <item>
                        <code>
            [ContractAnnotation("s:null =&gt; true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code>
                    </item>
                    <item>
                        <code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null =&gt; null; notnull =&gt; notnull")]
            public object Transform(object data)
            </code>
                    </item>
                    <item>
                        <code>
            [ContractAnnotation("=&gt; true, result: notnull; =&gt; false, result: null")]
            public bool TryParse(string s, out Person result)
            </code>
                    </item>
                </list>
            </examples>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
                Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library), so this symbol
                will not be reported as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
                Can be applied to attributes, type parameters, and parameters of a type assignable from
                <see cref="T:System.Type" /> . When applied to an attribute, the decorated attribute behaves the same as
                <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute" />. When applied to a type parameter or to a parameter of type
                <see cref="T:System.Type" />,  indicates that the corresponding type is used implicitly.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseKindFlags">
            <summary>
                Specify the details of implicitly used symbol when it is marked with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute" />
                or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute" />.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
                Indicates implicit instantiation of a type with fixed constructor signature. That means any unused constructor
                parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
                Specify what is considered to be used implicitly when marked with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute" /> or
                <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute" />.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:JetBrains.Annotations.PublicAPIAttribute">
            <summary>
                This attribute is intended to mark publicly available API which should not be removed and so is treated as
                used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
                Tells code analysis engine if the parameter is completely handled when the invoked method is on stack. If the
                parameter is a delegate, indicates that delegate is executed while the method is executed. If the parameter is an
                enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
                Indicates that a method does not make any observable state changes. The same as
                <c>System.Diagnostics.Contracts.PureAttribute</c>.
            </summary>
            <example>
                <code>
            [Pure] int Multiply(int x, int y) => x * y;
            
            void M() {
              Multiply(123, 42); // Waring: Return value of pure method is not used
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.MustUseReturnValueAttribute">
            <summary>Indicates that the return value of the method invocation must be used.</summary>
            <remarks>
                Methods decorated with this attribute (in contrast to pure methods) might change state, but make no sense
                without using their return value. <br /> Similarly to <see cref="T:JetBrains.Annotations.PureAttribute" />, this attribute will help
                detecting usages of the method when the return value in not used. Additionally, you can optionally specify a custom
                message, which will be used when showing warnings, e.g.
                <code>[MustUseReturnValue("Use the return value to...")]</code>.
            </remarks>
        </member>
        <member name="T:JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
                Indicates that the marked method is assertion method, i.e. it halts the control flow if one of the conditions
                is satisfied. To set the condition, mark one of the parameters with <see cref="T:JetBrains.Annotations.AssertionConditionAttribute" />
                attribute.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionAttribute">
            <summary>
                Indicates the condition parameter of the assertion method. The method itself should be marked by
                <see cref="T:JetBrains.Annotations.AssertionMethodAttribute" /> attribute. The mandatory argument of the attribute is the assertion type.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionType">
            <summary>
                Specifies assertion type. If the assertion method argument satisfies the condition, then the execution
                continues. Otherwise, execution is assumed to be halted.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_TRUE">
            <summary>Marked parameter should be evaluated to true.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_FALSE">
            <summary>Marked parameter should be evaluated to false.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NULL">
            <summary>Marked parameter should be evaluated to null value.</summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>Marked parameter should be evaluated to not null value.</summary>
        </member>
        <member name="T:JetBrains.Annotations.LinqTunnelAttribute">
            <summary>
                Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select, .Where). This
                annotation allows inference of [InstantHandle] annotation for parameters of delegate type by analyzing LINQ method
                chains.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.NoEnumerationAttribute">
            <summary>
                Indicates that IEnumerable passed as a parameter is not enumerated. Use this annotation to suppress the
                'Possible multiple enumeration of IEnumerable' inspection.
            </summary>
            <example>
                <code>
            static void ThrowIfNull&lt;T&gt;([NoEnumeration] T v, string n) where T : class
            {
              // custom check for null but no enumeration
            }
            
            void Foo(IEnumerable&lt;string&gt; values)
            {
              ThrowIfNull(values, nameof(values));
              var x = values.ToList(); // No warnings about multiple enumeration
            }
            </code>
            </example>
        </member>
        <member name="T:JetBrains.Annotations.NoReorderAttribute">
            <summary>Prevents the Member Reordering feature from tossing members of the marked class.</summary>
            <remarks>The attribute must be mentioned in your member reordering patterns.</remarks>
        </member>
    </members>
</doc>
