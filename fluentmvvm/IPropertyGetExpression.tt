<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<# Type[] types = { typeof(object), typeof(bool), typeof(byte), typeof(sbyte), typeof(char), typeof(decimal), typeof(double), typeof(float), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(DateTime), typeof(string) }; #>
// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
#nullable enable
using System;

namespace FluentMvvm
{
    /// <summary>
    ///     Provides methods that can be used to get the value of a property.
    /// </summary>
    internal interface IPropertyGetExpression
    {

<# foreach (Type type in types) { #>
        /// <summary>
        ///     Gets the value of the specified property.
        /// </summary>
        /// <param name="propertyName">
        ///     The name of the property. Filled in by the compiler automatically, do not specify explicitly.
        /// </param>
        /// <returns>
        ///     The value of the property.
        /// </returns>
        /// <exception cref="ArgumentException">
        ///     no public writable instance property named <paramref name="propertyName" /> could be found -or- <paramref name="propertyName" /> is empty or consists only of white-space characters.
        /// </exception>
        /// <exception cref="InvalidOperationException">
        ///     there are no backing fields of type <#= type == typeof(object) ? "<typeparamref name=\"T\" />" : "<see cref=\"" + type + "\" />" #>.
        /// </exception>
        <#= type == typeof(object) ? "T" : type.Name #> Get<#= type == typeof(object) ? "<T>" : type.Name #>(string propertyName = null);

<# } #>        
    }
}