<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<# Type[] types = { typeof(object), typeof(bool), typeof(byte), typeof(sbyte), typeof(char), typeof(decimal), typeof(double), typeof(float), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(DateTime), typeof(string) }; #>
// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using FluentMvvm.Internals;

namespace FluentMvvm
{
#if TEST
    internal class BackingFields : IBackingFields
#else
    internal sealed class BackingFields : IBackingFields
#endif
    {
#if TEST
        public virtual Type OnType { get; }
#else
        public Type OnType { get; }
#endif
        
#if TEST
<# foreach (Type type in types) { #>
        internal virtual FixedSizeDictionary<<#= type #>> <#= type.Name #>Fields { get; } = null!;
<# } #>
#else
<# foreach (Type type in types) { #>
        private FixedSizeDictionary<<#= type #>> <#= type.Name #>Fields;
<# } #>
#endif

#if TEST
        public BackingFields() 
        {
            this.OnType = default!;
        }
#endif

        public BackingFields(Type onType, ICollection<PropertyInfo> properties)
        {             
            this.OnType = onType;

<# foreach (Type type in types) { #>
<# if (type == typeof(object)) { #>
            this.<#= type.Name #>Fields = FixedSizeDictionary<<#= type #>>.Create(properties.Where(x => !TypeHelper.DoesOverloadExist(x.PropertyType)), x => x.Name, TypeHelper.GetDefaultValue);
<# } else { #>
            this.<#= type.Name #>Fields = FixedSizeDictionary<<#= type #>>.Create(properties.Where(x => x.PropertyType == typeof(<#= type #>)), x => x.Name, x => (<#= type #>) TypeHelper.GetDefaultValue(x)!);
<# } } #>
        }

<# foreach (Type type in types) { #>
#if TEST
        public virtual <#= type == typeof(object) ? "T" : type.Name #> Get<#= type == typeof(object) ? "<T>" : type.Name #>(string propertyName)
#else
        public <#= type == typeof(object) ? "T" : type.Name #> Get<#= type == typeof(object) ? "<T>" : type.Name #>(string propertyName)
#endif
        {
            Debug.Assert(!String.IsNullOrWhiteSpace(propertyName));

            if (this.<#= type.Name #>Fields.TryGetEntry(propertyName, out FixedSizeDictionary<<#= type #>>.Entry? entry))
            {
                return <#= type == typeof(object) ? "(T) " : String.Empty #>entry.Value;
            }

            propertyName = propertyName.NotNullOrEmptyOrWhiteSpace(nameof(propertyName));
            ThrowHelper.ThrowPropertyNotFound(propertyName, typeof(<#= type == typeof(object) ? "T" : type #>), this.OnType);
            return default; // to make the compiler happy
        }

<# } #>
<# foreach (Type type in types) { #>
#if TEST
        public virtual bool Set<#= type == typeof(object) ? "<T>" : String.Empty #>(<#= type == typeof(object) ? "T" : type.Name #> value, string propertyName)
#else
        public bool Set<#= type == typeof(object) ? "<T>" : String.Empty #>(<#= type == typeof(object) ? "T" : type.Name #> value, string propertyName)
#endif
        {
            Debug.Assert(!String.IsNullOrWhiteSpace(propertyName));

            if (this.<#= type.Name #>Fields.TryGetEntry(propertyName, out FixedSizeDictionary<<#= type #>>.Entry? entry))
            {
<# if (type == typeof(object)) { #>
                if (EqualityComparer<T>.Default.Equals((T) entry.Value, value))
                {
                    return false;
                }
<# } else { #>
                if (entry.Value == value)
                {
                    return false;
                }

<# } #>
                entry.Value = value;
                return true;
            }
            
            propertyName = propertyName.NotNullOrEmptyOrWhiteSpace(nameof(propertyName));
            ThrowHelper.ThrowPropertyNotFound(propertyName, typeof(<#= type == typeof(object) ? "T" : type #>), this.OnType);
            return default; // to make the compiler happy
        }

<# } #>
    }
}
