<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<# Type[] types = { typeof(object), typeof(bool), typeof(byte), typeof(sbyte), typeof(char), typeof(decimal), typeof(double), typeof(float), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(DateTime), typeof(string) }; #>
// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
#nullable enable
using System;
using System.Runtime.CompilerServices;
using System.Windows.Input;

namespace FluentMvvm
{
    /// <summary>
    ///     An object implementing all fluent methods as methods doing nothing.
    /// </summary>
    /// <seealso cref="IPropertySetExpression" />
    /// <seealso cref="IDependencyExpression" />
    /// <seealso cref="IPropertySetExpression" />
    /// <seealso cref="IDependencyExpression" />
    internal sealed class EmptyFluentAction : IPropertySetExpression, IDependencyExpression
    {
        /// <summary>
        ///     Gets a singleton <see cref="EmptyFluentAction" />.
        /// </summary>
        /// <value>
        ///     A singleton instance of an <see cref="EmptyFluentAction" />.
        /// </value>
        public static EmptyFluentAction Default { get; } = new EmptyFluentAction();

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IDependencyExpression Affects(string propertyName)
        {
            propertyName.NotNullOrEmptyOrWhiteSpace(nameof(propertyName));

            return this;
        }     

        <# foreach (string s in new[]{"ICommand", "IWpfCommand"}) { #>
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IDependencyExpression Affects(<#= s #> command)
        {
            command.NotNull(nameof(command));

            return this;
        }
        <# } #>

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool WasUpdated()
        {
            return false;
        }

        <# foreach (Type type in types) { #>
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public IDependencyExpression Set<#= type == typeof(object) ? "<T>" : String.Empty #>(<#= type == typeof(object) ? "T" : type.Name #> value, [CallerMemberName] string propertyName = "")
        {            
            propertyName.NotNullOrEmptyOrWhiteSpace(nameof(propertyName));

            return this;
        }
        <# } #>

        /// <inheritdoc />
        public IDependencyExpression Set<T>(T value, ref T oldValue, [CallerMemberName] string propertyName = "")
        {
            propertyName.NotNullOrEmptyOrWhiteSpace(nameof(propertyName));

            return this;
        }
    }
}