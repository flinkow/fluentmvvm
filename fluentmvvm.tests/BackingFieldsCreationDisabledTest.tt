<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<# Type[] types = { typeof(object), typeof(bool), typeof(byte), typeof(sbyte), typeof(char), typeof(decimal), typeof(double), typeof(float), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(DateTime), typeof(string) }; #>
// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Windows.Input;
using AutoFixture;
using AutoFixture.AutoMoq;
using AutoFixture.Xunit2;
using Microsoft.CSharp.RuntimeBinder;
using Moq;
using Shouldly;
using Xunit;
using FluentMvvm.Internals;

namespace FluentMvvm.Tests
{
    public class BackingFieldsCreationDisabledTest
    {
<# foreach (Type type in types) { #>

        [Fact]
        public void Get<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
<# if (type == typeof(object)) { #>
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Get<<#= type.Name #>>(propertyName));
<# } else { #>
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Get<#= type.Name #>(propertyName));
<# } #>            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(<#= type #>).Name);
            exception.Message.ShouldContain("no backing fields");
        }
<# } #>
        

<# foreach (Type type in types) { #>

        [Fact]
        public void Set<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<<#= type #>>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(<#= type #>).Name);
            exception.Message.ShouldContain("no backing fields");
        }
<# } #>

    }
}