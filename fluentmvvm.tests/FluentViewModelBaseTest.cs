// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Windows.Input;
using AutoFixture;
using AutoFixture.AutoMoq;
using AutoFixture.Xunit2;
using Microsoft.CSharp.RuntimeBinder;
using Moq;
using Shouldly;
using Xunit;

namespace FluentMvvm.Tests
{
    public interface ICommandWithRaiseCanExecuteChanged : ICommand
    {
        void RaiseCanExecuteChanged();
    }

    public class FluentViewModelBaseTest
    {
        [Fact]
        public void Constructor_CreateBackingFields_CreatesBackingFields()
        {
            // Arrange
            var viewModelMock = new Mock<FluentViewModelBase>(true) { CallBase = true };

            // Act
            var viewModel = viewModelMock.Object;

            // Assert
            viewModel.BackingFields.ShouldBeOfType(typeof(BackingFields));
        }

        [Fact]
        public void Constructor_DoNotCreateBackingFields_DoesNotCreateBackingFields()
        {
            // Arrange
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };

            // Act
            var viewModel = viewModelMock.Object;

            // Assert
            viewModel.BackingFields.ShouldBeOfType(typeof(BackingFieldsCreationDisabled));
        }

        [Fact]
        public void AffectsProperty_RaisesEventAndReturnsSelf()
        {
            // Arrange
            var viewModelMock = new Mock<FluentViewModelBase>(false);
            viewModelMock.Setup(x => x.RaisePropertyChanged(It.IsAny<string>()));
            var viewModel = viewModelMock.Object;
            
            var propertyName = new Fixture().Create<string>();

            // Act
            var returnValue = ((IDependencyExpression) viewModel).Affects(propertyName);
            
            // Assert
            returnValue.ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once);
        }

        [Theory]
        [InlineData(null)]
        [InlineData("")]
        [InlineData(" ")]
        public void AffectsProperty_NullEmptyOrWhiteSpace_ShouldThrow(string propertyName)
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;

            // Act & Assert
            Should.Throw<ArgumentException>(() => ((IDependencyExpression) viewModel).Affects(propertyName));
        }

        [Fact]
        public void AffectsICommand_NoRaiseCanExecuteChanged_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture().Customize(new AutoMoqCustomization());
            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            var command = fixture.Create<ICommand>();

            // Act & Assert
            Should.Throw<RuntimeBinderException>(() => ((IDependencyExpression) viewModel).Affects(command));
        }

        [Fact]
        public void AffectsICommand_Null_ShouldThrow()
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;

            // Act & Assert
            Should.Throw<ArgumentNullException>(() => ((IDependencyExpression) viewModel).Affects((ICommand) null));
        }

        [Fact]
        public void AffectsICommand_WithMethod_CallsMethodAndReturnsSelf()
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            var commandMock = new Mock<ICommandWithRaiseCanExecuteChanged>();
            commandMock.Setup(x => x.RaiseCanExecuteChanged());
            var command = commandMock.Object;

            // Act
            var returnValue = ((IDependencyExpression) viewModel).Affects(command);

            // Assert
            returnValue.ShouldBeSameAs(viewModel);

            commandMock.Verify(x => x.RaiseCanExecuteChanged(), Times.Once);
        }

        [Fact]
        public void AffectsIWpfCommand_CallsMethodAndReturnsSelf()
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            var commandMock = new Mock<IWpfCommand>();
            commandMock.Setup(x => x.RaiseCanExecuteChanged());
            var command = commandMock.Object;

            // Act
            var returnValue = ((IDependencyExpression) viewModel).Affects(command);

            // Assert
            returnValue.ShouldBeSameAs(viewModel);
            
            commandMock.Verify(x => x.RaiseCanExecuteChanged(), Times.Once);
        }

        [Fact]
        public void AffectsWpfCommand_Null_ShouldThrow()
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;

            // Act & Assert
            Should.Throw<ArgumentNullException>(() => ((IDependencyExpression) viewModel).Affects((IWpfCommand) null));
        }

        [Fact]
        public void WasUpdated_ReturnsTrue()
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;

            // Act & Assert
            ((IDependencyExpression) viewModel).WasUpdated().ShouldBeTrue();
        } 

        [Fact]
        public void When_True_ReturnsSelf()
        {
            // Arrange
            var fixture = new Fixture();

            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            
            // Act
            var returnValue = viewModel.When(true);
            
            // Assert
            returnValue.ShouldBeSameAs(viewModel);
        }

        [Fact]
        public void When_False_ReturnsEmptyFluentAction()
        {
            // Arrange
            var fixture = new Fixture();

            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            
            // Act
            var returnValue = viewModel.When(false);
            
            // Assert
            returnValue.ShouldBeSameAs(EmptyFluentAction.Default);
        }

        [Fact]
        public void When_FuncNull_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var viewModel = new Mock<FluentViewModelBase>(false) { CallBase = true }.Object;

            // Act & Assert
            Should.Throw<ArgumentNullException>(() => viewModel.When(default(Func<bool>)));
        }

        [Fact]
        public void When_FuncTrue_ReturnsSelf()
        {
            // Arrange
            var fixture = new Fixture();

            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            
            // Act
            var returnValue = viewModel.When(() => true);
            
            // Assert
            returnValue.ShouldBeSameAs(viewModel);
        }

        [Fact]
        public void When_FuncFalse_ReturnsEmptyFluentAction()
        {
            // Arrange
            var fixture = new Fixture();

            var viewModel = new Mock<FluentViewModelBase>(false) { CallBase = true }.Object;
            
            // Act
            var returnValue = viewModel.When(() => false);
            
            // Assert
            returnValue.ShouldBeSameAs(EmptyFluentAction.Default);
        }

        [Fact]
        public void RaisePropertyChanged_RaisesEvent()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var viewModel = new Mock<FluentViewModelBase>(false) { CallBase = true }.Object;

            var eventList = new List<(object Sender, PropertyChangedEventArgs Args)>();

            viewModel.PropertyChanged += (sender, args) => eventList.Add((sender, args));

            // Act
            viewModel.RaisePropertyChanged(propertyName);

            // Assert
            eventList.Count.ShouldBe(1);
            
            eventList[0].Sender.ShouldBeSameAs(viewModel);
            eventList[0].Args.PropertyName.ShouldBe(propertyName);
        }


        [Fact]
        public void GetGeneric_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Get<Object>(propertyName));
        
            exception.Message.ShouldContain(typeof(System.Object).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetBoolean_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetBoolean(propertyName));
        
            exception.Message.ShouldContain(typeof(System.Boolean).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetByte_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetByte(propertyName));
        
            exception.Message.ShouldContain(typeof(System.Byte).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetSByte_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetSByte(propertyName));
        
            exception.Message.ShouldContain(typeof(System.SByte).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetChar_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetChar(propertyName));
        
            exception.Message.ShouldContain(typeof(System.Char).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetDecimal_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetDecimal(propertyName));
        
            exception.Message.ShouldContain(typeof(System.Decimal).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetDouble_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetDouble(propertyName));
        
            exception.Message.ShouldContain(typeof(System.Double).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetSingle_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetSingle(propertyName));
        
            exception.Message.ShouldContain(typeof(System.Single).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetInt16_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetInt16(propertyName));
        
            exception.Message.ShouldContain(typeof(System.Int16).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetUInt16_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetUInt16(propertyName));
        
            exception.Message.ShouldContain(typeof(System.UInt16).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetInt32_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetInt32(propertyName));
        
            exception.Message.ShouldContain(typeof(System.Int32).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetUInt32_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetUInt32(propertyName));
        
            exception.Message.ShouldContain(typeof(System.UInt32).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetInt64_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetInt64(propertyName));
        
            exception.Message.ShouldContain(typeof(System.Int64).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetUInt64_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetUInt64(propertyName));
        
            exception.Message.ShouldContain(typeof(System.UInt64).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetDateTime_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetDateTime(propertyName));
        
            exception.Message.ShouldContain(typeof(System.DateTime).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void GetString_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.GetString(propertyName));
        
            exception.Message.ShouldContain(typeof(System.String).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }


        [Fact]
        public void GetGeneric_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.Get<Object>(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Get<Object>(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Object).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetBoolean_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetBoolean(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetBoolean(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Boolean).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetByte_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetByte(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetByte(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Byte).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetSByte_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetSByte(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetSByte(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.SByte).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetChar_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetChar(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetChar(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Char).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetDecimal_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetDecimal(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetDecimal(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Decimal).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetDouble_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetDouble(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetDouble(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Double).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetSingle_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetSingle(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetSingle(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Single).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetInt16_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetInt16(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetInt16(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int16).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetUInt16_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetUInt16(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetUInt16(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt16).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetInt32_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetInt32(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetInt32(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int32).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetUInt32_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetUInt32(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetUInt32(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt32).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetInt64_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetInt64(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetInt64(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int64).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetUInt64_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetUInt64(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetUInt64(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt64).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetDateTime_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetDateTime(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetDateTime(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.DateTime).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetString_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetString(It.IsAny<string>())).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetString(propertyName));
     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.String).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }


        [Fact]
        public void GetGeneric_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.Get<Object>(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Get<Object>(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Object).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetBoolean_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetBoolean(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetBoolean(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Boolean).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetByte_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetByte(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetByte(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Byte).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetSByte_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetSByte(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetSByte(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.SByte).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetChar_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetChar(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetChar(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Char).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetDecimal_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetDecimal(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetDecimal(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Decimal).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetDouble_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetDouble(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetDouble(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Double).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetSingle_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetSingle(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetSingle(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Single).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetInt16_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetInt16(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetInt16(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int16).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetUInt16_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetUInt16(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetUInt16(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt16).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetInt32_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetInt32(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetInt32(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int32).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetUInt32_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetUInt32(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetUInt32(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt32).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetInt64_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetInt64(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetInt64(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int64).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetUInt64_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetUInt64(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetUInt64(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt64).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetDateTime_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetDateTime(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetDateTime(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.DateTime).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetString_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetString(propertyName)).Throws<ArgumentException>();
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.GetString(propertyName));
      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.String).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }


        [Fact]
        public void GetGeneric_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Object>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.Get<Object>(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Get<Object>(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetBoolean_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Boolean>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetBoolean(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetBoolean(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetByte_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Byte>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetByte(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetByte(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetSByte_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.SByte>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetSByte(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetSByte(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetChar_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Char>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetChar(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetChar(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetDecimal_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Decimal>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetDecimal(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetDecimal(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetDouble_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Double>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetDouble(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetDouble(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetSingle_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Single>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetSingle(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetSingle(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetInt16_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Int16>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetInt16(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetInt16(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetUInt16_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.UInt16>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetUInt16(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetUInt16(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetInt32_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Int32>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetInt32(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetInt32(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetUInt32_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.UInt32>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetUInt32(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetUInt32(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetInt64_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Int64>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetInt64(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetInt64(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetUInt64_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.UInt64>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetUInt64(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetUInt64(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetDateTime_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.DateTime>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetDateTime(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetDateTime(propertyName).ShouldBe(value);
         
        }

        [Fact]
        public void GetString_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.String>();

            var backingFieldsMock = new Mock<BackingFields>();

            backingFieldsMock.Setup(x => x.GetString(propertyName)).Returns(value);
            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.GetString(propertyName).ShouldBe(value);
         
        }


        [Fact]
        public void SetGeneric_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.Object>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.Object).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetBoolean_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.Boolean>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.Boolean).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetByte_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.Byte>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.Byte).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetSByte_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.SByte>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.SByte).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetChar_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.Char>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.Char).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetDecimal_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.Decimal>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.Decimal).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetDouble_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.Double>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.Double).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetSingle_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.Single>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.Single).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetInt16_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.Int16>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.Int16).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetUInt16_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.UInt16>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.UInt16).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetInt32_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.Int32>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.Int32).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetUInt32_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.UInt32>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.UInt32).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetInt64_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.Int64>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.Int64).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetUInt64_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.UInt64>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.UInt64).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetDateTime_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.DateTime>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.DateTime).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }

        [Fact]
        public void SetString_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<System.String>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(System.String).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }


        [Fact]
        public void SetGeneric_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.Object>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Object>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Object).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetBoolean_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.Boolean>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Boolean>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Boolean).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetByte_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.Byte>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Byte>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Byte).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetSByte_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.SByte>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.SByte>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.SByte).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetChar_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.Char>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Char>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Char).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetDecimal_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.Decimal>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Decimal>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Decimal).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetDouble_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.Double>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Double>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Double).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetSingle_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.Single>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Single>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Single).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetInt16_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.Int16>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Int16>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int16).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetUInt16_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.UInt16>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.UInt16>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt16).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetInt32_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.Int32>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Int32>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int32).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetUInt32_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.UInt32>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.UInt32>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt32).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetInt64_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.Int64>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Int64>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int64).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetUInt64_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.UInt64>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.UInt64>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt64).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetDateTime_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.DateTime>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.DateTime>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.DateTime).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetString_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<System.String>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.String>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.String).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }


        [Fact]
        public void SetGeneric_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.Object>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Object>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Object).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetBoolean_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.Boolean>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Boolean>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Boolean).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetByte_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.Byte>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Byte>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Byte).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetSByte_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.SByte>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.SByte>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.SByte).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetChar_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.Char>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Char>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Char).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetDecimal_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.Decimal>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Decimal>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Decimal).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetDouble_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.Double>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Double>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Double).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetSingle_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.Single>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Single>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Single).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetInt16_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.Int16>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Int16>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int16).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetUInt16_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.UInt16>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.UInt16>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt16).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetInt32_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.Int32>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Int32>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int32).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetUInt32_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.UInt32>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.UInt32>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt32).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetInt64_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.Int64>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.Int64>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.Int64).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetUInt64_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.UInt64>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.UInt64>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.UInt64).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetDateTime_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.DateTime>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.DateTime>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.DateTime).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetString_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<System.String>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<System.String>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(System.String).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }


        [Fact]
        public void SetGeneric_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Object>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetBoolean_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Boolean>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetByte_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Byte>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetSByte_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.SByte>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetChar_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Char>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetDecimal_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Decimal>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetDouble_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Double>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetSingle_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Single>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetInt16_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Int16>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetUInt16_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.UInt16>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetInt32_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Int32>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetUInt32_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.UInt32>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetInt64_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Int64>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetUInt64_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.UInt64>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetDateTime_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.DateTime>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }

        [Fact]
        public void SetString_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.String>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(), Times.Once());
        }


        [Fact]
        public void SetGeneric_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Object>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetBoolean_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Boolean>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetByte_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Byte>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetSByte_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.SByte>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetChar_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Char>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetDecimal_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Decimal>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetDouble_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Double>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetSingle_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Single>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetInt16_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Int16>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetUInt16_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.UInt16>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetInt32_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Int32>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetUInt32_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.UInt32>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetInt64_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.Int64>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetUInt64_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.UInt64>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetDateTime_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.DateTime>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetString_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<System.String>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet());
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(), Times.Never());
        }

        [Fact]
        public void SetRef_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEvent()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<int>();
            var oldValue = value + 1;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, ref oldValue, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
        }

        [Fact]
        public void SetRef_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<int>();
            var oldValue = value;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, ref oldValue, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
        }
    }
}