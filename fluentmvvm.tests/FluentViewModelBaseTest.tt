<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<# Type[] types = { typeof(object), typeof(bool), typeof(byte), typeof(sbyte), typeof(char), typeof(decimal), typeof(double), typeof(float), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(DateTime), typeof(string) }; #>
// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Windows.Input;
using AutoFixture;
using AutoFixture.AutoMoq;
using AutoFixture.Xunit2;
using Microsoft.CSharp.RuntimeBinder;
using Moq;
using Shouldly;
using Xunit;

namespace FluentMvvm.Tests
{
    public interface ICommandWithRaiseCanExecuteChanged : ICommand
    {
        void RaiseCanExecuteChanged();
    }

    public class FluentViewModelBaseTest
    {
        [Fact]
        public void Constructor_CreateBackingFields_CreatesBackingFields()
        {
            // Arrange
            var viewModelMock = new Mock<FluentViewModelBase>(true) { CallBase = true };

            // Act
            var viewModel = viewModelMock.Object;

            // Assert
            viewModel.BackingFields.ShouldBeOfType(typeof(BackingFields));
        }

        [Fact]
        public void Constructor_DoNotCreateBackingFields_DoesNotCreateBackingFields()
        {
            // Arrange
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };

            // Act
            var viewModel = viewModelMock.Object;

            // Assert
            viewModel.BackingFields.ShouldBeOfType(typeof(BackingFieldsCreationDisabled));
        }

        [Fact]
        public void AffectsProperty_RaisesEventAndReturnsSelf()
        {
            // Arrange
            var viewModelMock = new Mock<FluentViewModelBase>(false);
            viewModelMock.Setup(x => x.RaisePropertyChanged(It.IsAny<string>()));
            var viewModel = viewModelMock.Object;
            
            var propertyName = new Fixture().Create<string>();

            // Act
            var returnValue = ((IDependencyExpression) viewModel).Affects(propertyName);
            
            // Assert
            returnValue.ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once);
        }

        [Theory]
        [InlineData(null)]
        [InlineData("")]
        [InlineData(" ")]
        public void AffectsProperty_NullEmptyOrWhiteSpace_ShouldThrow(string propertyName)
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;

            // Act & Assert
            Should.Throw<ArgumentException>(() => ((IDependencyExpression) viewModel).Affects(propertyName));
        }

        [Fact]
        public void AffectsICommand_NoRaiseCanExecuteChanged_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture().Customize(new AutoMoqCustomization());
            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            var command = fixture.Create<ICommand>();

            // Act & Assert
            Should.Throw<RuntimeBinderException>(() => ((IDependencyExpression) viewModel).Affects(command));
        }

        [Fact]
        public void AffectsICommand_Null_ShouldThrow()
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;

            // Act & Assert
            Should.Throw<ArgumentNullException>(() => ((IDependencyExpression) viewModel).Affects((ICommand) null));
        }

        [Fact]
        public void AffectsICommand_WithMethod_CallsMethodAndReturnsSelf()
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            var commandMock = new Mock<ICommandWithRaiseCanExecuteChanged>();
            commandMock.Setup(x => x.RaiseCanExecuteChanged());
            var command = commandMock.Object;

            // Act
            var returnValue = ((IDependencyExpression) viewModel).Affects(command);

            // Assert
            returnValue.ShouldBeSameAs(viewModel);

            commandMock.Verify(x => x.RaiseCanExecuteChanged(), Times.Once);
        }

        [Fact]
        public void AffectsIWpfCommand_CallsMethodAndReturnsSelf()
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            var commandMock = new Mock<IWpfCommand>();
            commandMock.Setup(x => x.RaiseCanExecuteChanged());
            var command = commandMock.Object;

            // Act
            var returnValue = ((IDependencyExpression) viewModel).Affects(command);

            // Assert
            returnValue.ShouldBeSameAs(viewModel);
            
            commandMock.Verify(x => x.RaiseCanExecuteChanged(), Times.Once);
        }

        [Fact]
        public void AffectsWpfCommand_Null_ShouldThrow()
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;

            // Act & Assert
            Should.Throw<ArgumentNullException>(() => ((IDependencyExpression) viewModel).Affects((IWpfCommand) null));
        }

        [Fact]
        public void WasUpdated_ReturnsTrue()
        {
            // Arrange
            var viewModel = new Mock<FluentViewModelBase>(false).Object;

            // Act & Assert
            ((IDependencyExpression) viewModel).WasUpdated().ShouldBeTrue();
        } 

        [Fact]
        public void When_True_ReturnsSelf()
        {
            // Arrange
            var fixture = new Fixture();

            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            
            // Act
            var returnValue = viewModel.When(true);
            
            // Assert
            returnValue.ShouldBeSameAs(viewModel);
        }

        [Fact]
        public void When_False_ReturnsEmptyFluentAction()
        {
            // Arrange
            var fixture = new Fixture();

            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            
            // Act
            var returnValue = viewModel.When(false);
            
            // Assert
            returnValue.ShouldBeSameAs(EmptyFluentAction.Default);
        }

        [Fact]
        public void When_FuncNull_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var viewModel = new Mock<FluentViewModelBase>(false) { CallBase = true }.Object;

            // Act & Assert
            Should.Throw<ArgumentNullException>(() => viewModel.When(default(Func<bool>)));
        }

        [Fact]
        public void When_FuncTrue_ReturnsSelf()
        {
            // Arrange
            var fixture = new Fixture();

            var viewModel = new Mock<FluentViewModelBase>(false).Object;
            
            // Act
            var returnValue = viewModel.When(() => true);
            
            // Assert
            returnValue.ShouldBeSameAs(viewModel);
        }

        [Fact]
        public void When_FuncFalse_ReturnsEmptyFluentAction()
        {
            // Arrange
            var fixture = new Fixture();

            var viewModel = new Mock<FluentViewModelBase>(false) { CallBase = true }.Object;
            
            // Act
            var returnValue = viewModel.When(() => false);
            
            // Assert
            returnValue.ShouldBeSameAs(EmptyFluentAction.Default);
        }

        [Fact]
        public void RaisePropertyChanged_RaisesEvent()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var viewModel = new Mock<FluentViewModelBase>(false) { CallBase = true }.Object;

            var eventList = new List<(object Sender, PropertyChangedEventArgs Args)>();

            viewModel.PropertyChanged += (sender, args) => eventList.Add((sender, args));

            // Act
            viewModel.RaisePropertyChanged(propertyName);

            // Assert
            eventList.Count.ShouldBe(1);
            
            eventList[0].Sender.ShouldBeSameAs(viewModel);
            eventList[0].Args.PropertyName.ShouldBe(propertyName);
        }

<# foreach (Type type in types) { #>

        [Fact]
        public void Get<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();    
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
<# if (type == typeof(object)) { #>
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Get<<#= type.Name #>>(propertyName));
<# } else { #>
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Get<#= type.Name #>(propertyName));
<# } #>        
            exception.Message.ShouldContain(typeof(<#= type #>).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Get<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

<# if (type == typeof(object)) { #>
            backingFieldsMock.Setup(x => x.Get<<#= type.Name #>>(It.IsAny<string>())).Throws<ArgumentException>();
<# } else { #>
            backingFieldsMock.Setup(x => x.Get<#= type.Name #>(It.IsAny<string>())).Throws<ArgumentException>();
<# } #>            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
<# if (type == typeof(object)) { #>
            var exception = Should.Throw<ArgumentException>(() => viewModel.Get<<#= type.Name #>>(propertyName));
<# } else { #>
            var exception = Should.Throw<ArgumentException>(() => viewModel.Get<#= type.Name #>(propertyName));
<# } #>     
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(<#= type #>).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Get<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var backingFieldsMock = new Mock<BackingFields>();

<# if (type == typeof(object)) { #>
            backingFieldsMock.Setup(x => x.Get<<#= type.Name #>>(propertyName)).Throws<ArgumentException>();
<# } else { #>
            backingFieldsMock.Setup(x => x.Get<#= type.Name #>(propertyName)).Throws<ArgumentException>();
<# } #>            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
<# if (type == typeof(object)) { #>
            var exception = Should.Throw<ArgumentException>(() => viewModel.Get<<#= type.Name #>>(propertyName));
<# } else { #>
            var exception = Should.Throw<ArgumentException>(() => viewModel.Get<#= type.Name #>(propertyName));
<# } #>      
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(<#= type #>).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Get<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<<#= type #>>();

            var backingFieldsMock = new Mock<BackingFields>();

<# if (type == typeof(object)) { #>
            backingFieldsMock.Setup(x => x.Get<<#= type.Name #>>(propertyName)).Returns(value);
<# } else { #>
            backingFieldsMock.Setup(x => x.Get<#= type.Name #>(propertyName)).Returns(value);
<# } #>            
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(It.IsAny<bool>()) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
<# if (type == typeof(object)) { #>
            viewModel.Get<<#= type.Name #>>(propertyName).ShouldBe(value);
<# } else { #>
            viewModel.Get<#= type.Name #>(propertyName).ShouldBe(value);
<# } #>         
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Set<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_NoBackingFieldCreation_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var value = fixture.Create<<#= type #>>();
            
            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };            
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => viewModel.Set(value, propertyName));       
            exception.Message.ShouldContain(typeof(<#= type #>).Name);
            exception.Message.ShouldContain("backing fields");
            exception.Message.ShouldContain("creation");
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Set<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();        
            var value = fixture.Create<<#= type #>>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<<#= type #>>(), It.IsAny<string>())).Throws<ArgumentException>();       
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(<#= type #>).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Set<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();      
            var value = fixture.Create<<#= type #>>(); 

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(It.IsAny<<#= type #>>(), propertyName)).Throws<ArgumentException>();

            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            var viewModel = viewModelMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => viewModel.Set(value, propertyName));            
            // We mock the actual exception throwing code.
            //exception.Message.ShouldContain(propertyName);
            //exception.Message.ShouldContain(typeof(<#= type #>).Name);
            //exception.Message.ShouldContain("public writable instance property");
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Set<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEventAndCallsAfterSet()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<<#= type #>>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(true);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet(value, propertyName));
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
            viewModelMock.Verify(x => x.AfterSet(value, propertyName), Times.Once());
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Set<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<<#= type #>>();

            var backingFieldsMock = new Mock<BackingFields>();
            backingFieldsMock.Setup(x => x.Set(value, propertyName)).Returns(false);
            var backingFields = backingFieldsMock.Object;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };  
            viewModelMock.SetupGet(x => x.BackingFields).Returns(backingFields);
            viewModelMock.Setup(x => x.AfterSet(It.IsAny<<#= type #>>(), It.IsAny<string>()));
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
            viewModelMock.Verify(x => x.AfterSet(It.IsAny<<#= type #>>(), It.IsAny<string>()), Times.Never());
        }
<# } #>

        [Fact]
        public void SetRef_ExistingPropertyAndDifferentValue_SetsValueAndRaisesEvent()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<int>();
            var oldValue = value + 1;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, ref oldValue, propertyName).ShouldBeSameAs(viewModel);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Once());
        }

        [Fact]
        public void SetRef_ExistingPropertyAndSameValue_DoesNothing()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>(); 
            var value = fixture.Create<int>();
            var oldValue = value;            

            var viewModelMock = new Mock<FluentViewModelBase>(false) { CallBase = true };
            var viewModel = viewModelMock.Object;

            // Act & Assert
            viewModel.Set(value, ref oldValue, propertyName).ShouldBeSameAs(EmptyFluentAction.Default);
            viewModelMock.Verify(x => x.RaisePropertyChanged(propertyName), Times.Never());
        }
    }
}