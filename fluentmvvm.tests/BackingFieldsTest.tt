<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<# Type[] types = { typeof(object), typeof(bool), typeof(byte), typeof(sbyte), typeof(char), typeof(decimal), typeof(double), typeof(float), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(DateTime), typeof(string) }; #>
// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Windows.Input;
using AutoFixture;
using AutoFixture.AutoMoq;
using AutoFixture.Xunit2;
using Microsoft.CSharp.RuntimeBinder;
using Moq;
using Shouldly;
using Xunit;
using FluentMvvm.Internals;

namespace FluentMvvm.Tests
{
    public class BackingFieldsTest
    {
        [Fact]
        public void Constructor_InitializesBackingFields()
        {
            // Arrange
            var properties = new List<PropertyInfo>();
            Mock<PropertyInfo> propertyInfoMock;
<# foreach (Type type in types) { #>
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(<#= type #>));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
<# } #>
            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), properties }) { CallBase = true };
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
<# foreach (Type type in types) { #>
            backingFields.<#= type.Name #>Fields.ShouldNotBeNull();
<# } #>
        }

<# foreach (Type type in types) { #>

        [Fact]
        public void Get<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<<#= type #>>>();                      
            var entry = new FixedSizeDictionary<<#= type #>>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.<#= type.Name #>Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
<# if (type == typeof(object)) { #>
            var exception = Should.Throw<ArgumentException>(() => backingFields.Get<<#= type.Name #>>(propertyName));
<# } else { #>
            var exception = Should.Throw<ArgumentException>(() => backingFields.Get<#= type.Name #>(propertyName));
<# } #>
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(<#= type #>).Name);
            exception.Message.ShouldContain("public writable instance property");
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Get<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<<#= type #>>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<<#= type #>>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.<#= type.Name #>Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
<# if (type == typeof(object)) { #>
            var value = backingFields.Get<<#= type #>>(propertyName);
<# } else { #>
            var value = backingFields.Get<#= type.Name #>(propertyName);
<# } #>

            // Assert
            value.ShouldBe(entry.Value);
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Set<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<<#= type #>>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<<#= type #>>>();
            var entry = new FixedSizeDictionary<<#= type #>>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.<#= type.Name #>Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(<#= type #>).Name);
            exception.Message.ShouldContain("public writable instance property");
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Set<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<<#= type #>>();
            var newValue = fixture.Create<<#= type #>>();                      

            var entry = new FixedSizeDictionary<<#= type #>>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<<#= type #>>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.<#= type.Name #>Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }
<# } #>

<# foreach (Type type in types) { #>

        [Fact]
        public void Set<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<<#= type #>>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<<#= type #>>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<<#= type #>>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.<#= type.Name #>Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }
<# } #>

    }
}