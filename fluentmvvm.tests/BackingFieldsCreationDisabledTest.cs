// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Windows.Input;
using AutoFixture;
using AutoFixture.AutoMoq;
using AutoFixture.Xunit2;
using Microsoft.CSharp.RuntimeBinder;
using Moq;
using Shouldly;
using Xunit;
using FluentMvvm.Internals;

namespace FluentMvvm.Tests
{
    public class BackingFieldsCreationDisabledTest
    {

        [Fact]
        public void GetGeneric_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Get<Object>(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Object).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetBoolean_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetBoolean(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Boolean).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetByte_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetByte(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Byte).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetSByte_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetSByte(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.SByte).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetChar_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetChar(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Char).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetDecimal_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetDecimal(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Decimal).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetDouble_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetDouble(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Double).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetSingle_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetSingle(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Single).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetInt16_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetInt16(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int16).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetUInt16_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetUInt16(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt16).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetInt32_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetInt32(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int32).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetUInt32_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetUInt32(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt32).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetInt64_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetInt64(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int64).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetUInt64_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetUInt64(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt64).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetDateTime_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetDateTime(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.DateTime).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void GetString_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };            
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.GetString(propertyName));
            
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.String).Name);
            exception.Message.ShouldContain("no backing fields");
        }
        


        [Fact]
        public void SetGeneric_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Object>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Object).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetBoolean_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Boolean>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Boolean).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetByte_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Byte>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Byte).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetSByte_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.SByte>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.SByte).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetChar_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Char>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Char).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetDecimal_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Decimal>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Decimal).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetDouble_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Double>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Double).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetSingle_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Single>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Single).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetInt16_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Int16>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int16).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetUInt16_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.UInt16>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt16).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetInt32_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Int32>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int32).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetUInt32_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.UInt32>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt32).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetInt64_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Int64>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int64).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetUInt64_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.UInt64>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt64).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetDateTime_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.DateTime>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.DateTime).Name);
            exception.Message.ShouldContain("no backing fields");
        }

        [Fact]
        public void SetString_NoFieldsOfType_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.String>();
            var type = typeof(IWpfCommand);

            var backingFieldsMock = new Mock<BackingFieldsCreationDisabled> { CallBase = true };          
            backingFieldsMock.SetupGet(x => x.OnType).Returns(type);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<InvalidOperationException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.String).Name);
            exception.Message.ShouldContain("no backing fields");
        }

    }
}