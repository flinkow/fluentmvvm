<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<# Type[] types = { typeof(object), typeof(bool), typeof(byte), typeof(sbyte), typeof(char), typeof(decimal), typeof(double), typeof(float), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(DateTime), typeof(string) }; #>
// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
using System;
using System.Drawing;
using System.Windows.Input;
using AutoFixture;
using AutoFixture.AutoMoq;
using AutoFixture.Xunit2;
using Shouldly;
using Xunit;

namespace FluentMvvm.Tests
{
    public class EmptyFluentActionTest
    {
        [Fact]
        public void DefaultInstance_IsNotNull()
        {
            EmptyFluentAction.Default.ShouldNotBeNull();
        }

        [Fact]
        public void AffectsProperty_ReturnsSelf()
        {
            // Arrange
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            emptyFluentAction.Affects(new Fixture().Create<string>()).ShouldBeSameAs(emptyFluentAction);
        }

        [Theory]
        [InlineData(null)]
        [InlineData("")]
        [InlineData(" ")]
        public void AffectsProperty_NullEmptyOrWhiteSpace_ShouldThrow(string propertyName)
        {
            // Arrange
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            ArgumentException exception = Should.Throw<ArgumentException>(() => emptyFluentAction.Affects(propertyName));
            exception.Message.ShouldContain("null");
            exception.Message.ShouldContain("empty");
            exception.Message.ShouldContain("white-space characters");
        }

        [Fact]
        public void AffectsICommand_ReturnsSelf()
        {
            // Arrange
            var fixture = new Fixture().Customize(new AutoMoqCustomization());
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            emptyFluentAction.Affects(fixture.Create<ICommand>()).ShouldBeSameAs(emptyFluentAction);
        }

        [Fact]
        public void AffectsICommand_Null_ShouldThrow()
        {
            // Arrange
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            Should.Throw<ArgumentNullException>(() => emptyFluentAction.Affects((ICommand) null));
        }

        [Fact]
        public void AffectsIWpfCommand_ReturnsSelf()
        {
            // Arrange
            var fixture = new Fixture().Customize(new AutoMoqCustomization());
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            emptyFluentAction.Affects(fixture.Create<IWpfCommand>()).ShouldBeSameAs(emptyFluentAction);
        }

        [Fact]
        public void AffectsWpfCommand_Null_ShouldThrow()
        {
            // Arrange
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            Should.Throw<ArgumentNullException>(() => emptyFluentAction.Affects((IWpfCommand) null));
        }

        [Fact]
        public void WasUpdated_ReturnsFalse()
        {
            // Arrange
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            emptyFluentAction.WasUpdated().ShouldBeFalse();
        }

        <# foreach (Type type in types) { #>

        [Theory]
        [AutoData]
        public void Set_<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>_ReturnsSelf(string propertyName, <#= type.Name #> value)
        {
            // Arrange
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            emptyFluentAction.Set(value, propertyName).ShouldBeSameAs(emptyFluentAction);
        }
<# } #>

        [Theory]
        [AutoData]
        public void SetRef_ReturnsSelf(string propertyName, int value)
        {
            // Arrange
            var oldValue = new Fixture().Create<int>();
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            emptyFluentAction.Set(value, ref oldValue, propertyName).ShouldBeSameAs(emptyFluentAction);
        }

        <# foreach (Type type in types) { #>

        [Theory]
        [InlineAutoData(null)]
        [InlineAutoData("")]
        [InlineAutoData(" ")]
        public void Set_<#= type.Name == typeof(object).Name ? "Generic" : type.Name #>WithNullEmptyOrWhiteSpace_ShouldThrow(string propertyName, <#= type.Name #> value)
        {
            // Arrange
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            ArgumentException exception = Should.Throw<ArgumentException>(() => emptyFluentAction.Set(value, propertyName));
            exception.Message.ShouldContain("null");
            exception.Message.ShouldContain("empty");
            exception.Message.ShouldContain("white-space characters");
        }
<# } #>

        [Theory]
        [InlineAutoData(null)]
        [InlineAutoData("")]
        [InlineAutoData(" ")]
        public void SetRef_WithNullEmptyOrWhiteSpace_ShouldThrow(string propertyName, int value)
        {
            // Arrange
            var oldValue = new Fixture().Create<int>();
            var emptyFluentAction = new EmptyFluentAction();

            // Act & Assert
            ArgumentException exception = Should.Throw<ArgumentException>(() => emptyFluentAction.Set(value, ref oldValue, propertyName));
            exception.Message.ShouldContain("null");
            exception.Message.ShouldContain("empty");
            exception.Message.ShouldContain("white-space characters");
        }
    }
}