// <auto-generated>
// This file is generated by a T4 template. Make changes directly in the .tt file.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Windows.Input;
using AutoFixture;
using AutoFixture.AutoMoq;
using AutoFixture.Xunit2;
using Microsoft.CSharp.RuntimeBinder;
using Moq;
using Shouldly;
using Xunit;
using FluentMvvm.Internals;

namespace FluentMvvm.Tests
{
    public class BackingFieldsTest
    {
        [Fact]
        public void Constructor_InitializesBackingFields()
        {
            // Arrange
            var properties = new List<PropertyInfo>();
            Mock<PropertyInfo> propertyInfoMock;
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.Object));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.Boolean));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.Byte));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.SByte));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.Char));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.Decimal));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.Double));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.Single));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.Int16));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.UInt16));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.Int32));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.UInt32));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.Int64));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.UInt64));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.DateTime));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            propertyInfoMock = new Mock<PropertyInfo>();
            propertyInfoMock.SetupGet(x => x.PropertyType).Returns(typeof(System.String));
            propertyInfoMock.SetupGet(x => x.Name).Returns(new Fixture().Create<string>());

            properties.Add(propertyInfoMock.Object);
            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), properties }) { CallBase = true };
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            backingFields.ObjectFields.ShouldNotBeNull();
            backingFields.BooleanFields.ShouldNotBeNull();
            backingFields.ByteFields.ShouldNotBeNull();
            backingFields.SByteFields.ShouldNotBeNull();
            backingFields.CharFields.ShouldNotBeNull();
            backingFields.DecimalFields.ShouldNotBeNull();
            backingFields.DoubleFields.ShouldNotBeNull();
            backingFields.SingleFields.ShouldNotBeNull();
            backingFields.Int16Fields.ShouldNotBeNull();
            backingFields.UInt16Fields.ShouldNotBeNull();
            backingFields.Int32Fields.ShouldNotBeNull();
            backingFields.UInt32Fields.ShouldNotBeNull();
            backingFields.Int64Fields.ShouldNotBeNull();
            backingFields.UInt64Fields.ShouldNotBeNull();
            backingFields.DateTimeFields.ShouldNotBeNull();
            backingFields.StringFields.ShouldNotBeNull();
        }


        [Fact]
        public void GetGeneric_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Object>>();                      
            var entry = new FixedSizeDictionary<System.Object>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.ObjectFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Get<Object>(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Object).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetBoolean_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Boolean>>();                      
            var entry = new FixedSizeDictionary<System.Boolean>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.BooleanFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetBoolean(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Boolean).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetByte_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Byte>>();                      
            var entry = new FixedSizeDictionary<System.Byte>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.ByteFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetByte(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Byte).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetSByte_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.SByte>>();                      
            var entry = new FixedSizeDictionary<System.SByte>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.SByteFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetSByte(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.SByte).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetChar_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Char>>();                      
            var entry = new FixedSizeDictionary<System.Char>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.CharFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetChar(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Char).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetDecimal_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Decimal>>();                      
            var entry = new FixedSizeDictionary<System.Decimal>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DecimalFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetDecimal(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Decimal).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetDouble_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Double>>();                      
            var entry = new FixedSizeDictionary<System.Double>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DoubleFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetDouble(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Double).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetSingle_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Single>>();                      
            var entry = new FixedSizeDictionary<System.Single>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.SingleFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetSingle(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Single).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetInt16_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int16>>();                      
            var entry = new FixedSizeDictionary<System.Int16>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int16Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetInt16(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int16).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetUInt16_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt16>>();                      
            var entry = new FixedSizeDictionary<System.UInt16>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt16Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetUInt16(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt16).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetInt32_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int32>>();                      
            var entry = new FixedSizeDictionary<System.Int32>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int32Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetInt32(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int32).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetUInt32_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt32>>();                      
            var entry = new FixedSizeDictionary<System.UInt32>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt32Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetUInt32(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt32).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetInt64_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int64>>();                      
            var entry = new FixedSizeDictionary<System.Int64>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int64Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetInt64(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int64).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetUInt64_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt64>>();                      
            var entry = new FixedSizeDictionary<System.UInt64>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt64Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetUInt64(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt64).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetDateTime_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.DateTime>>();                      
            var entry = new FixedSizeDictionary<System.DateTime>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DateTimeFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetDateTime(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.DateTime).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void GetString_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();               
            var type = typeof(FluentViewModelBase);
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.String>>();                      
            var entry = new FixedSizeDictionary<System.String>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.StringFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.GetString(propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.String).Name);
            exception.Message.ShouldContain("public writable instance property");
        }


        [Fact]
        public void GetGeneric_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.Object>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Object>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.ObjectFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.Get<System.Object>(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetBoolean_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.Boolean>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Boolean>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.BooleanFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetBoolean(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetByte_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.Byte>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Byte>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.ByteFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetByte(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetSByte_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.SByte>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.SByte>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.SByteFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetSByte(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetChar_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.Char>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Char>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.CharFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetChar(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetDecimal_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.Decimal>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Decimal>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DecimalFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetDecimal(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetDouble_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.Double>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Double>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DoubleFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetDouble(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetSingle_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.Single>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Single>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.SingleFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetSingle(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetInt16_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.Int16>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int16>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int16Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetInt16(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetUInt16_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.UInt16>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt16>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt16Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetUInt16(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetInt32_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.Int32>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int32>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int32Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetInt32(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetUInt32_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.UInt32>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt32>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt32Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetUInt32(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetInt64_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.Int64>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int64>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int64Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetInt64(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetUInt64_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.UInt64>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt64>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt64Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetUInt64(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetDateTime_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.DateTime>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.DateTime>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DateTimeFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetDateTime(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }

        [Fact]
        public void GetString_ExistingProperty_ReturnsValue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();       
            var entry = new FixedSizeDictionary<System.String>.Entry();
            
            var dictionaryMock = new Mock<FixedSizeDictionary<System.String>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(), new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.StringFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var value = backingFields.GetString(propertyName);

            // Assert
            value.ShouldBe(entry.Value);
        }


        [Fact]
        public void SetGeneric_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Object>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Object>>();
            var entry = new FixedSizeDictionary<System.Object>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.ObjectFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Object).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetBoolean_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Boolean>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Boolean>>();
            var entry = new FixedSizeDictionary<System.Boolean>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.BooleanFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Boolean).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetByte_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Byte>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Byte>>();
            var entry = new FixedSizeDictionary<System.Byte>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.ByteFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Byte).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetSByte_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.SByte>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.SByte>>();
            var entry = new FixedSizeDictionary<System.SByte>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.SByteFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.SByte).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetChar_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Char>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Char>>();
            var entry = new FixedSizeDictionary<System.Char>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.CharFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Char).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetDecimal_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Decimal>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Decimal>>();
            var entry = new FixedSizeDictionary<System.Decimal>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DecimalFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Decimal).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetDouble_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Double>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Double>>();
            var entry = new FixedSizeDictionary<System.Double>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DoubleFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Double).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetSingle_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Single>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Single>>();
            var entry = new FixedSizeDictionary<System.Single>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.SingleFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Single).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetInt16_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Int16>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int16>>();
            var entry = new FixedSizeDictionary<System.Int16>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int16Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int16).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetUInt16_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.UInt16>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt16>>();
            var entry = new FixedSizeDictionary<System.UInt16>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt16Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt16).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetInt32_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Int32>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int32>>();
            var entry = new FixedSizeDictionary<System.Int32>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int32Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int32).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetUInt32_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.UInt32>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt32>>();
            var entry = new FixedSizeDictionary<System.UInt32>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt32Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt32).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetInt64_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.Int64>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int64>>();
            var entry = new FixedSizeDictionary<System.Int64>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int64Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.Int64).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetUInt64_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.UInt64>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt64>>();
            var entry = new FixedSizeDictionary<System.UInt64>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt64Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.UInt64).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetDateTime_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.DateTime>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.DateTime>>();
            var entry = new FixedSizeDictionary<System.DateTime>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DateTimeFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.DateTime).Name);
            exception.Message.ShouldContain("public writable instance property");
        }

        [Fact]
        public void SetString_NotExistingProperty_ShouldThrow()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();
            var value = fixture.Create<System.String>(); 
            
            var type = typeof(FluentViewModelBase);

            var dictionaryMock = new Mock<FixedSizeDictionary<System.String>>();
            var entry = new FixedSizeDictionary<System.String>.Entry();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(false);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { type, new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.StringFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act & Assert
            var exception = Should.Throw<ArgumentException>(() => backingFields.Set(value, propertyName));
            exception.Message.ShouldContain(propertyName);
            exception.Message.ShouldContain(type.Name);
            exception.Message.ShouldContain(typeof(System.String).Name);
            exception.Message.ShouldContain("public writable instance property");
        }


        [Fact]
        public void SetGeneric_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Object>();
            var newValue = fixture.Create<System.Object>();                      

            var entry = new FixedSizeDictionary<System.Object>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Object>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.ObjectFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetBoolean_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Boolean>();
            var newValue = fixture.Create<System.Boolean>();                      

            var entry = new FixedSizeDictionary<System.Boolean>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Boolean>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.BooleanFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetByte_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Byte>();
            var newValue = fixture.Create<System.Byte>();                      

            var entry = new FixedSizeDictionary<System.Byte>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Byte>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.ByteFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetSByte_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.SByte>();
            var newValue = fixture.Create<System.SByte>();                      

            var entry = new FixedSizeDictionary<System.SByte>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.SByte>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.SByteFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetChar_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Char>();
            var newValue = fixture.Create<System.Char>();                      

            var entry = new FixedSizeDictionary<System.Char>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Char>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.CharFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetDecimal_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Decimal>();
            var newValue = fixture.Create<System.Decimal>();                      

            var entry = new FixedSizeDictionary<System.Decimal>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Decimal>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DecimalFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetDouble_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Double>();
            var newValue = fixture.Create<System.Double>();                      

            var entry = new FixedSizeDictionary<System.Double>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Double>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DoubleFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetSingle_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Single>();
            var newValue = fixture.Create<System.Single>();                      

            var entry = new FixedSizeDictionary<System.Single>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Single>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.SingleFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetInt16_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Int16>();
            var newValue = fixture.Create<System.Int16>();                      

            var entry = new FixedSizeDictionary<System.Int16>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int16>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int16Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetUInt16_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.UInt16>();
            var newValue = fixture.Create<System.UInt16>();                      

            var entry = new FixedSizeDictionary<System.UInt16>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt16>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt16Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetInt32_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Int32>();
            var newValue = fixture.Create<System.Int32>();                      

            var entry = new FixedSizeDictionary<System.Int32>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int32>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int32Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetUInt32_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.UInt32>();
            var newValue = fixture.Create<System.UInt32>();                      

            var entry = new FixedSizeDictionary<System.UInt32>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt32>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt32Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetInt64_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Int64>();
            var newValue = fixture.Create<System.Int64>();                      

            var entry = new FixedSizeDictionary<System.Int64>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int64>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int64Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetUInt64_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.UInt64>();
            var newValue = fixture.Create<System.UInt64>();                      

            var entry = new FixedSizeDictionary<System.UInt64>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt64>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt64Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetDateTime_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.DateTime>();
            var newValue = fixture.Create<System.DateTime>();                      

            var entry = new FixedSizeDictionary<System.DateTime>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.DateTime>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DateTimeFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }

        [Fact]
        public void SetString_ExistingPropertyAndDifferentValue_ReturnsTrue()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.String>();
            var newValue = fixture.Create<System.String>();                      

            var entry = new FixedSizeDictionary<System.String>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.String>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.StringFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeTrue();
        }


        [Fact]
        public void SetGeneric_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Object>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.Object>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Object>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.ObjectFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetBoolean_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Boolean>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.Boolean>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Boolean>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.BooleanFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetByte_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Byte>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.Byte>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Byte>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.ByteFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetSByte_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.SByte>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.SByte>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.SByte>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.SByteFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetChar_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Char>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.Char>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Char>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.CharFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetDecimal_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Decimal>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.Decimal>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Decimal>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DecimalFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetDouble_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Double>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.Double>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Double>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DoubleFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetSingle_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Single>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.Single>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Single>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.SingleFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetInt16_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Int16>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.Int16>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int16>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int16Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetUInt16_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.UInt16>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.UInt16>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt16>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt16Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetInt32_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Int32>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.Int32>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int32>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int32Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetUInt32_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.UInt32>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.UInt32>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt32>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt32Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetInt64_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.Int64>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.Int64>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.Int64>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.Int64Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetUInt64_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.UInt64>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.UInt64>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.UInt64>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.UInt64Fields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetDateTime_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.DateTime>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.DateTime>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.DateTime>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.DateTimeFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

        [Fact]
        public void SetString_ExistingPropertyAndSameValue_ReturnsFalse()
        {
            // Arrange
            var fixture = new Fixture();

            var propertyName = fixture.Create<string>();

            var oldValue = fixture.Create<System.String>();
            var newValue = oldValue;                    

            var entry = new FixedSizeDictionary<System.String>.Entry(propertyName, oldValue, fixture.Create<int>());

            var dictionaryMock = new Mock<FixedSizeDictionary<System.String>>();
            dictionaryMock.Setup(x => x.TryGetEntry(It.IsAny<string>(), out entry)).Returns(true);

            var backingFieldsMock = new Mock<BackingFields>(args: new object[] { It.IsAny<Type>(),new PropertyInfo[0] }) { CallBase = true };
            backingFieldsMock.SetupGet(x => x.StringFields).Returns(dictionaryMock.Object);
            var backingFields = backingFieldsMock.Object;

            // Act
            var returnValue = backingFields.Set(newValue, propertyName);

            // Assert
            returnValue.ShouldBeFalse();
        }

    }
}